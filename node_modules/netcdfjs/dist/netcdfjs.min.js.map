{"version":3,"sources":["webpack://netcdfjs/webpack/universalModuleDefinition","webpack://netcdfjs/webpack/bootstrap","webpack://netcdfjs/./src/utils.js","webpack://netcdfjs/./node_modules/utf8/utf8.js","webpack://netcdfjs/./src/types.js","webpack://netcdfjs/./src/index.js","webpack://netcdfjs/../src/IOBuffer.ts","webpack://netcdfjs/./src/data.js","webpack://netcdfjs/./src/header.js","webpack://netcdfjs/./src/toString.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","padding","buffer","offset","skip","notNetcdf","statement","reason","TypeError","concat","readName","nameLength","readUint32","readChars","byteArray","byteCount","byteIndex","stringFromCharCode","String","fromCharCode","ucs2decode","string","extra","output","counter","length","charCodeAt","push","checkScalarValue","codePoint","Error","toString","toUpperCase","createByte","shift","encodeCodePoint","symbol","readContinuationByte","continuationByte","decodeSymbol","byte1","version","encode","codePoints","index","byteString","decode","tmp","array","ucs2encode","require","types","BYTE","CHAR","SHORT","INT","FLOAT","DOUBLE","readNumber","size","bufferReader","numbers","Array","num2str","type","Number","num2bytes","str2num","readType","readBytes","substring","readInt16","readInt32","readFloat32","readFloat64","IOBuffer","utils","data","readHeader","constructor","setBigEndian","readByte","header","recordDimension","dimensions","globalAttributes","getAttribute","attributeName","attribute","find","val","getDataVariableAsString","variableName","variable","getDataVariable","join","variables","undefined","seek","record","nonRecord","dataVariableExists","attributeExists","__webpack_exports__","utf8__WEBPACK_IMPORTED_MODULE_0__","defaultByteLength","[object Object]","arguments","options","dataIsGiven","ArrayBuffer","lastWrittenByte","byteLength","dvOffset","isView","byteOffset","littleEndian","_data","DataView","_mark","_marks","pop","available","newLength","newArray","Uint8Array","set","readUint8","getInt8","getUint8","bytes","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","readInt8","result","readChar","bString","writeUint8","ensureAvailable","setInt8","_updateLastWrittenByte","setUint8","setInt16","setUint16","setInt32","setUint32","setFloat32","setFloat64","str","writeChars","width","step","recordStep","currentOffset","ZERO","NC_DIMENSION","NC_VARIABLE","NC_ATTRIBUTE","NC_UNLIMITED","attributesList","gAttList","attributeSize","attributes","gAtt","dimList","recordId","recordName","dimensionSize","dim","dimensionsList","id","varList","variableSize","v","dimensionality","dimensionsIds","varSize","variablesList","dimension","padEnd","JSON","parse","stringify","isNaN"],"mappings":"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","file":"netcdfjs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"netcdfjs\"] = factory();\n\telse\n\t\troot[\"netcdfjs\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","'use strict';\n\n/**\n * Throws a non-valid NetCDF exception if the statement it's true\n * @ignore\n * @param {boolean} statement - Throws if true\n * @param {string} reason - Reason to throw\n */\nfunction notNetcdf(statement, reason) {\n  if (statement) {\n    throw new TypeError(`Not a valid NetCDF v3.x file: ${reason}`);\n  }\n}\n\n/**\n * Moves 1, 2, or 3 bytes to next 4-byte boundary\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n */\nfunction padding(buffer) {\n  if ((buffer.offset % 4) !== 0) {\n    buffer.skip(4 - (buffer.offset % 4));\n  }\n}\n\n\n/**\n * Reads the name\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @return {string} - Name\n */\nfunction readName(buffer) {\n  // Read name\n  var nameLength = buffer.readUint32();\n  var name = buffer.readChars(nameLength);\n\n  // validate name\n  // TODO\n\n  // Apply padding\n  padding(buffer);\n  return name;\n}\n\nmodule.exports.notNetcdf = notNetcdf;\nmodule.exports.padding = padding;\nmodule.exports.readName = readName;\n","/*! https://mths.be/utf8js v3.0.0 by @mathias */\n;(function(root) {\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\troot.version = '3.0.0';\n\troot.encode = utf8encode;\n\troot.decode = utf8decode;\n\n}(typeof exports === 'undefined' ? this.utf8 = {} : exports));\n","'use strict';\n\nconst notNetcdf = require('./utils').notNetcdf;\n\nconst types = {\n  BYTE: 1,\n  CHAR: 2,\n  SHORT: 3,\n  INT: 4,\n  FLOAT: 5,\n  DOUBLE: 6\n};\n\n/**\n * Parse a number into their respective type\n * @ignore\n * @param {number} type - integer that represents the type\n * @return {string} - parsed value of the type\n */\nfunction num2str(type) {\n  switch (Number(type)) {\n    case types.BYTE:\n      return 'byte';\n    case types.CHAR:\n      return 'char';\n    case types.SHORT:\n      return 'short';\n    case types.INT:\n      return 'int';\n    case types.FLOAT:\n      return 'float';\n    case types.DOUBLE:\n      return 'double';\n      /* istanbul ignore next */\n    default:\n      return 'undefined';\n  }\n}\n\n/**\n * Parse a number type identifier to his size in bytes\n * @ignore\n * @param {number} type - integer that represents the type\n * @return {number} -size of the type\n */\nfunction num2bytes(type) {\n  switch (Number(type)) {\n    case types.BYTE:\n      return 1;\n    case types.CHAR:\n      return 1;\n    case types.SHORT:\n      return 2;\n    case types.INT:\n      return 4;\n    case types.FLOAT:\n      return 4;\n    case types.DOUBLE:\n      return 8;\n      /* istanbul ignore next */\n    default:\n      return -1;\n  }\n}\n\n/**\n * Reverse search of num2str\n * @ignore\n * @param {string} type - string that represents the type\n * @return {number} - parsed value of the type\n */\nfunction str2num(type) {\n  switch (String(type)) {\n    case 'byte':\n      return types.BYTE;\n    case 'char':\n      return types.CHAR;\n    case 'short':\n      return types.SHORT;\n    case 'int':\n      return types.INT;\n    case 'float':\n      return types.FLOAT;\n    case 'double':\n      return types.DOUBLE;\n      /* istanbul ignore next */\n    default:\n      return -1;\n  }\n}\n\n/**\n * Auxiliary function to read numeric data\n * @ignore\n * @param {number} size - Size of the element to read\n * @param {function} bufferReader - Function to read next value\n * @return {Array<number>|number}\n */\nfunction readNumber(size, bufferReader) {\n  if (size !== 1) {\n    var numbers = new Array(size);\n    for (var i = 0; i < size; i++) {\n      numbers[i] = bufferReader();\n    }\n    return numbers;\n  } else {\n    return bufferReader();\n  }\n}\n\n/**\n * Given a type and a size reads the next element\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @param {number} type - Type of the data to read\n * @param {number} size - Size of the element to read\n * @return {string|Array<number>|number}\n */\nfunction readType(buffer, type, size) {\n  switch (type) {\n    case types.BYTE:\n      return buffer.readBytes(size);\n    case types.CHAR:\n      return trimNull(buffer.readChars(size));\n    case types.SHORT:\n      return readNumber(size, buffer.readInt16.bind(buffer));\n    case types.INT:\n      return readNumber(size, buffer.readInt32.bind(buffer));\n    case types.FLOAT:\n      return readNumber(size, buffer.readFloat32.bind(buffer));\n    case types.DOUBLE:\n      return readNumber(size, buffer.readFloat64.bind(buffer));\n      /* istanbul ignore next */\n    default:\n      notNetcdf(true, `non valid type ${type}`);\n      return undefined;\n  }\n}\n\n/**\n * Removes null terminate value\n * @ignore\n * @param {string} value - String to trim\n * @return {string} - Trimmed string\n */\nfunction trimNull(value) {\n  if (value.charCodeAt(value.length - 1) === 0) {\n    return value.substring(0, value.length - 1);\n  }\n  return value;\n}\n\nmodule.exports = types;\nmodule.exports.num2str = num2str;\nmodule.exports.num2bytes = num2bytes;\nmodule.exports.str2num = str2num;\nmodule.exports.readType = readType;\n","'use strict';\n\nconst { IOBuffer } = require('iobuffer');\n\nconst utils = require('./utils');\nconst data = require('./data');\nconst readHeader = require('./header');\nconst toString = require('./toString');\n\n/**\n * Reads a NetCDF v3.x file\n * https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html\n * @param {ArrayBuffer} data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\n * @constructor\n */\nclass NetCDFReader {\n  constructor(data) {\n    const buffer = new IOBuffer(data);\n    buffer.setBigEndian();\n\n    // Validate that it's a NetCDF file\n    utils.notNetcdf(buffer.readChars(3) !== 'CDF', 'should start with CDF');\n\n    // Check the NetCDF format\n    const version = buffer.readByte();\n    utils.notNetcdf(version > 2, 'unknown version');\n\n    // Read the header\n    this.header = readHeader(buffer, version);\n    this.buffer = buffer;\n  }\n\n  /**\n   * @return {string} - Version for the NetCDF format\n   */\n  get version() {\n    if (this.header.version === 1) {\n      return 'classic format';\n    } else {\n      return '64-bit offset format';\n    }\n  }\n\n  /**\n   * @return {object} - Metadata for the record dimension\n   *  * `length`: Number of elements in the record dimension\n   *  * `id`: Id number in the list of dimensions for the record dimension\n   *  * `name`: String with the name of the record dimension\n   *  * `recordStep`: Number with the record variables step size\n   */\n  get recordDimension() {\n    return this.header.recordDimension;\n  }\n\n  /**\n   * @return {Array<object>} - List of dimensions with:\n   *  * `name`: String with the name of the dimension\n   *  * `size`: Number with the size of the dimension\n   */\n  get dimensions() {\n    return this.header.dimensions;\n  }\n\n  /**\n   * @return {Array<object>} - List of global attributes with:\n   *  * `name`: String with the name of the attribute\n   *  * `type`: String with the type of the attribute\n   *  * `value`: A number or string with the value of the attribute\n   */\n  get globalAttributes() {\n    return this.header.globalAttributes;\n  }\n\n  /**\n   * Returns the value of an attribute\n   * @param {string} attributeName\n   * @return {string} Value of the attributeName or null\n   */\n  getAttribute(attributeName) {\n    const attribute = this.globalAttributes.find(\n      (val) => val.name === attributeName\n    );\n    if (attribute) return attribute.value;\n    return null;\n  }\n\n  /**\n   * Returns the value of a variable as a string\n   * @param {string} variableName\n   * @return {string} Value of the variable as a string or null\n   */\n  getDataVariableAsString(variableName) {\n    const variable = this.getDataVariable(variableName);\n    if (variable) return variable.join('');\n    return null;\n  }\n\n  /**\n   * @return {Array<object>} - List of variables with:\n   *  * `name`: String with the name of the variable\n   *  * `dimensions`: Array with the dimension IDs of the variable\n   *  * `attributes`: Array with the attributes of the variable\n   *  * `type`: String with the type of the variable\n   *  * `size`: Number with the size of the variable\n   *  * `offset`: Number with the offset where of the variable begins\n   *  * `record`: True if is a record variable, false otherwise\n   */\n  get variables() {\n    return this.header.variables;\n  }\n\n  toString() {\n    return toString.call(this);\n  }\n\n  /**\n   * Retrieves the data for a given variable\n   * @param {string|object} variableName - Name of the variable to search or variable object\n   * @return {Array} - List with the variable values\n   */\n  getDataVariable(variableName) {\n    let variable;\n    if (typeof variableName === 'string') {\n      // search the variable\n      variable = this.header.variables.find(function (val) {\n        return val.name === variableName;\n      });\n    } else {\n      variable = variableName;\n    }\n\n    // throws if variable not found\n    utils.notNetcdf(\n      variable === undefined,\n      `variable not found: ${variableName}`\n    );\n\n    // go to the offset position\n    this.buffer.seek(variable.offset);\n\n    if (variable.record) {\n      // record variable case\n      return data.record(this.buffer, variable, this.header.recordDimension);\n    } else {\n      // non-record variable case\n      return data.nonRecord(this.buffer, variable);\n    }\n  }\n\n  /**\n   * Check if a dataVariable exists\n   * @param {string} variableName - Name of the variable to find\n   * @return {boolean}\n   */\n  dataVariableExists(variableName) {\n    const variable = this.header.variables.find(function (val) {\n      return val.name === variableName;\n    });\n    return variable !== undefined;\n  }\n\n  /**\n   * Check if an attribute exists\n   * @param {string} attributeName - Name of the attribute to find\n   * @return {boolean}\n   */\n  attributeExists(attributeName) {\n    const attribute = this.globalAttributes.find(\n      (val) => val.name === attributeName\n    );\n    return attribute !== undefined;\n  }\n}\n\nmodule.exports = NetCDFReader;\n","import { decode, encode } from 'utf8';\nconst defaultByteLength = 1024 * 8;\nexport class IOBuffer {\n    /**\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     */\n    readBytes(n = 1) {\n        const bytes = new Uint8Array(n);\n        for (let i = 0; i < n; i++) {\n            bytes[i] = this.readByte();\n        }\n        return bytes;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     */\n    readChar() {\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     */\n    readUtf8(n = 1) {\n        const bString = this.readChars(n);\n        return decode(bString);\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     */\n    writeChar(str) {\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     */\n    writeUtf8(str) {\n        const bString = encode(str);\n        return this.writeChars(bString);\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=IOBuffer.js.map","'use strict';\n\nconst types = require('./types');\n\n// const STREAMING = 4294967295;\n\n/**\n * Read data for the given non-record variable\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @param {object} variable - Variable metadata\n * @return {Array} - Data of the element\n */\nfunction nonRecord(buffer, variable) {\n  // variable type\n  const type = types.str2num(variable.type);\n\n  // size of the data\n  var size = variable.size / types.num2bytes(type);\n\n  // iterates over the data\n  var data = new Array(size);\n  for (var i = 0; i < size; i++) {\n    data[i] = types.readType(buffer, type, 1);\n  }\n\n  return data;\n}\n\n/**\n * Read data for the given record variable\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @param {object} variable - Variable metadata\n * @param {object} recordDimension - Record dimension metadata\n * @return {Array} - Data of the element\n */\nfunction record(buffer, variable, recordDimension) {\n  // variable type\n  const type = types.str2num(variable.type);\n  const width = variable.size ? variable.size / types.num2bytes(type) : 1;\n\n  // size of the data\n  // TODO streaming data\n  var size = recordDimension.length;\n\n  // iterates over the data\n  var data = new Array(size);\n  const step = recordDimension.recordStep;\n\n  for (var i = 0; i < size; i++) {\n    var currentOffset = buffer.offset;\n    data[i] = types.readType(buffer, type, width);\n    buffer.seek(currentOffset + step);\n  }\n\n  return data;\n}\n\nmodule.exports.nonRecord = nonRecord;\nmodule.exports.record = record;\n","'use strict';\n\nconst utils = require('./utils');\nconst types = require('./types');\n\n// Grammar constants\nconst ZERO = 0;\nconst NC_DIMENSION = 10;\nconst NC_VARIABLE = 11;\nconst NC_ATTRIBUTE = 12;\n\n/**\n * Read the header of the file\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @param {number} version - Version of the file\n * @return {object} - Object with the fields:\n *  * `recordDimension`: Number with the length of record dimension\n *  * `dimensions`: List of dimensions\n *  * `globalAttributes`: List of global attributes\n *  * `variables`: List of variables\n */\nfunction header(buffer, version) {\n  // Length of record dimension\n  // sum of the varSize's of all the record variables.\n  var header = { recordDimension: { length: buffer.readUint32() } };\n\n  // Version\n  header.version = version;\n\n  // List of dimensions\n  var dimList = dimensionsList(buffer);\n  header.recordDimension.id = dimList.recordId; // id of the unlimited dimension\n  header.recordDimension.name = dimList.recordName; // name of the unlimited dimension\n  header.dimensions = dimList.dimensions;\n\n  // List of global attributes\n  header.globalAttributes = attributesList(buffer);\n\n  // List of variables\n  var variables = variablesList(buffer, dimList.recordId, version);\n  header.variables = variables.variables;\n  header.recordDimension.recordStep = variables.recordStep;\n\n  return header;\n}\n\nconst NC_UNLIMITED = 0;\n\n/**\n * List of dimensions\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @return {object} - Ojbect containing the following properties:\n *  * `dimensions` that is an array of dimension object:\n  *  * `name`: String with the name of the dimension\n  *  * `size`: Number with the size of the dimension dimensions: dimensions\n *  * `recordId`: the id of the dimension that has unlimited size or undefined,\n *  * `recordName`: name of the dimension that has unlimited size\n */\nfunction dimensionsList(buffer) {\n  var recordId, recordName;\n  const dimList = buffer.readUint32();\n  if (dimList === ZERO) {\n    utils.notNetcdf((buffer.readUint32() !== ZERO), 'wrong empty tag for list of dimensions');\n    return [];\n  } else {\n    utils.notNetcdf((dimList !== NC_DIMENSION), 'wrong tag for list of dimensions');\n\n    // Length of dimensions\n    const dimensionSize = buffer.readUint32();\n    var dimensions = new Array(dimensionSize);\n    for (var dim = 0; dim < dimensionSize; dim++) {\n      // Read name\n      var name = utils.readName(buffer);\n\n      // Read dimension size\n      const size = buffer.readUint32();\n      if (size === NC_UNLIMITED) { // in netcdf 3 one field can be of size unlimmited\n        recordId = dim;\n        recordName = name;\n      }\n\n      dimensions[dim] = {\n        name: name,\n        size: size\n      };\n    }\n  }\n  return {\n    dimensions: dimensions,\n    recordId: recordId,\n    recordName: recordName\n  };\n}\n\n/**\n * List of attributes\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @return {Array<object>} - List of attributes with:\n *  * `name`: String with the name of the attribute\n *  * `type`: String with the type of the attribute\n *  * `value`: A number or string with the value of the attribute\n */\nfunction attributesList(buffer) {\n  const gAttList = buffer.readUint32();\n  if (gAttList === ZERO) {\n    utils.notNetcdf((buffer.readUint32() !== ZERO), 'wrong empty tag for list of attributes');\n    return [];\n  } else {\n    utils.notNetcdf((gAttList !== NC_ATTRIBUTE), 'wrong tag for list of attributes');\n\n    // Length of attributes\n    const attributeSize = buffer.readUint32();\n    var attributes = new Array(attributeSize);\n    for (var gAtt = 0; gAtt < attributeSize; gAtt++) {\n      // Read name\n      var name = utils.readName(buffer);\n\n      // Read type\n      var type = buffer.readUint32();\n      utils.notNetcdf(((type < 1) || (type > 6)), `non valid type ${type}`);\n\n      // Read attribute\n      var size = buffer.readUint32();\n      var value = types.readType(buffer, type, size);\n\n      // Apply padding\n      utils.padding(buffer);\n\n      attributes[gAtt] = {\n        name: name,\n        type: types.num2str(type),\n        value: value\n      };\n    }\n  }\n  return attributes;\n}\n\n/**\n * List of variables\n * @ignore\n * @param {IOBuffer} buffer - Buffer for the file data\n * @param {number} recordId - Id of the unlimited dimension (also called record dimension)\n *                            This value may be undefined if there is no unlimited dimension\n * @param {number} version - Version of the file\n * @return {object} - Number of recordStep and list of variables with:\n *  * `name`: String with the name of the variable\n *  * `dimensions`: Array with the dimension IDs of the variable\n *  * `attributes`: Array with the attributes of the variable\n *  * `type`: String with the type of the variable\n *  * `size`: Number with the size of the variable\n *  * `offset`: Number with the offset where of the variable begins\n *  * `record`: True if is a record variable, false otherwise (unlimited size)\n */\n\nfunction variablesList(buffer, recordId, version) {\n  const varList = buffer.readUint32();\n  var recordStep = 0;\n  if (varList === ZERO) {\n    utils.notNetcdf((buffer.readUint32() !== ZERO), 'wrong empty tag for list of variables');\n    return [];\n  } else {\n    utils.notNetcdf((varList !== NC_VARIABLE), 'wrong tag for list of variables');\n\n    // Length of variables\n    const variableSize = buffer.readUint32();\n    var variables = new Array(variableSize);\n    for (var v = 0; v < variableSize; v++) {\n      // Read name\n      var name = utils.readName(buffer);\n\n      // Read dimensionality of the variable\n      const dimensionality = buffer.readUint32();\n\n      // Index into the list of dimensions\n      var dimensionsIds = new Array(dimensionality);\n      for (var dim = 0; dim < dimensionality; dim++) {\n        dimensionsIds[dim] = buffer.readUint32();\n      }\n\n      // Read variables size\n      var attributes = attributesList(buffer);\n\n      // Read type\n      var type = buffer.readUint32();\n      utils.notNetcdf(((type < 1) && (type > 6)), `non valid type ${type}`);\n\n      // Read variable size\n      // The 32-bit varSize field is not large enough to contain the size of variables that require\n      // more than 2^32 - 4 bytes, so 2^32 - 1 is used in the varSize field for such variables.\n      const varSize = buffer.readUint32();\n\n      // Read offset\n      var offset = buffer.readUint32();\n      if (version === 2) {\n        utils.notNetcdf((offset > 0), 'offsets larger than 4GB not supported');\n        offset = buffer.readUint32();\n      }\n\n      let record = false;\n      // Count amount of record variables\n      if ((typeof recordId !== 'undefined') && (dimensionsIds[0] === recordId)) {\n        recordStep += varSize;\n        record = true;\n      }\n      variables[v] = {\n        name: name,\n        dimensions: dimensionsIds,\n        attributes,\n        type: types.num2str(type),\n        size: varSize,\n        offset,\n        record\n      };\n    }\n  }\n\n  return {\n    variables: variables,\n    recordStep: recordStep\n  };\n}\n\nmodule.exports = header;\n","'use strict';\n\nfunction toString() {\n  let result = [];\n\n  result.push('DIMENSIONS');\n  for (let dimension of this.dimensions) {\n    result.push(`  ${dimension.name.padEnd(30)} = size: ${dimension.size}`);\n  }\n\n  result.push('');\n  result.push('GLOBAL ATTRIBUTES');\n  for (let attribute of this.globalAttributes) {\n    result.push(`  ${attribute.name.padEnd(30)} = ${attribute.value}`);\n  }\n\n  let variables = JSON.parse(JSON.stringify(this.variables));\n  result.push('');\n  result.push('VARIABLES:');\n  for (let variable of variables) {\n    variable.value = this.getDataVariable(variable);\n    let stringify = JSON.stringify(variable.value);\n    if (stringify.length > 50) stringify = stringify.substring(0, 50);\n    if (!isNaN(variable.value.length)) {\n      stringify += ` (length: ${variable.value.length})`;\n    }\n    result.push(`  ${variable.name.padEnd(30)} = ${stringify}`);\n  }\n  return result.join('\\n');\n}\n\nmodule.exports = toString;\n"],"sourceRoot":""}